## KMP算法算法:

~~会了这道题，考研就过了......~~

### 能解决的问题：**kmp**算法是一种字符串匹配可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配

#### 前置知识：文本串text(较长)    模式串pattern(较短) , *目标：需要判断 pattern 是否是 text 的子串*

------



#### 1.前缀表(next) // c++里next是关键字，用不了可用nex代替

前缀表是什么意思呢？ 他表示我们要求的模式串的某一子串(此处称为  **s**子串  的最前k个字符串与最后k个字符串相等)

因此，next[i] 表示使字串 s[0…i] 中  <u>前缀 s[0…k]</u>   等于  <u>后缀 s[i-k…i]</u>   的**最大的 k**

如果找不到相等的前后缀，就令   **next[i] = -1 待定**。Obviously, next[i] 就是所求**最长相等前后缀中** <u>前缀的最后一位</u> 的**下标**。

**eg:** 注意相等的前缀、后缀在原字串中不能是 s[0…i] 本身

------



##### 接下来，就是如何求next数组的问题了

求next数组有多种方法，有些人从 0 下标开始，有些人从 1 开始，我就从 1 开始来写，next虽然不同但可以通过+1 -1 来转换变得相同

#### 2.进行kmp匹配

